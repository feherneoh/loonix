// SPDX-License-Identifier: GPL-2.0
#include <dt-bindings/input/input.h>

#include "qcom-msm8930.dtsi"
#include <dt-bindings/input/input.h>
#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>

/ {
    model = "Lumia 520";
    compatible = "qcom,msm8930", "qcom,msm8627", "qcom,msm8627-mtp", "qcom,msm8227";

	aliases {
		serial0 = &gsbi5_serial;
	};

	chosen {
		//bootargs = "cma=64m"; //from nicki@Konrad
		stdout-path = "serial0:115200n8";
	};

    soc {
		rpm@108000 {
			regulators {
				compatible = "qcom,rpm-pm8038-regulators";


				vdd_l1-supply = <&pm8038_s2>;
				vdd_l2_l20-supply = <&pm8038_s2>;
				vdd_l12_l24_l26-supply = <&pm8038_s2>;
				vdd_l16_l19-supply = <&pm8038_s3>;
				vdd_l27-supply = <&pm8038_s3>;
				vdd_l7_l11_l21_l23-supply = <&pm8038_s4>;
				vin_lvs1-supply = <&pm8038_l11>;			//Konrad has these merged on nicki
				vin_lvs2-supply = <&pm8038_l11>;			//Konrad has these merged on nicki
				// vdd_l8?
				// others on vph_pwr

				/* Core 1.15V */
				s1 {
					regulator-min-microvolt = <500000>;
					regulator-max-microvolt = <1150000>;
					qcom,switch-mode-frequency = <4800000>;
					bias-pull-down;
					//qcom,force-mode = <QCOM_RPM_FORCE_MODE_LPM>; //Konrad doesn't have this on nicki
				};

				/* 1.4V */
				s2 {
					regulator-always-on;
					regulator-min-microvolt = <1400000>;
					regulator-max-microvolt = <1400000>;
					qcom,switch-mode-frequency = <1600000>;
					bias-pull-down;
					//qcom,force-mode = <QCOM_RPM_FORCE_MODE_LPM>; //Konrad doesn't have this on nicki
				};

				/* 1.15V */
				s3 {
					regulator-min-microvolt = <1150000>;
					regulator-max-microvolt = <1150000>;
					qcom,switch-mode-frequency = <3200000>;
					bias-pull-down;
					//qcom,force-mode = <QCOM_RPM_FORCE_MODE_AUTO>; //Konrad doesn't have this on nicki
				};

				/* 2.2V */
				s4 {
					regulator-always-on;
					regulator-min-microvolt = <2200000>; //was 1950000, Konrad bumped it up on nicki
					regulator-max-microvolt = <2200000>;
					qcom,switch-mode-frequency = <1600000>;
					bias-pull-down;
					//qcom,force-mode = <QCOM_RPM_FORCE_MODE_LPM>; //Konrad doesn't have this on nicki
				};

				/* RF_CWS 1.3V */
				l1 {
					regulator-min-microvolt = <1300000>;
					regulator-max-microvolt = <1300000>;
					bias-pull-down;
				};

				/* MIPI 1.2V */
				l2 {
					regulator-min-microvolt = <1200000>;
					regulator-max-microvolt = <1200000>;
					bias-pull-down;

					regulator-system-load = <100000>;
					regulator-allow-set-load;
				};

				/* USB 3.075V (3.3V?) */
				l3 {
					regulator-min-microvolt = <3075000>;
					regulator-max-microvolt = <3075000>;
					bias-pull-down;
				};

				/* USB 1.8V */
				l4 {
					regulator-always-on;
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					bias-pull-down;

					regulator-system-load = <10000>;
					regulator-allow-set-load;
				};

				/* eMMC 2.95V */
				l5 {
					regulator-min-microvolt = <2950000>;
					regulator-max-microvolt = <2950000>;
					bias-pull-down;
				};

				/* SD 2.95V */
				l6 {
					regulator-min-microvolt = <2950000>;
					regulator-max-microvolt = <2950000>;
					bias-pull-down;
				};

				/* RF 2.05V */
				l7 {
					regulator-min-microvolt = <2050000>;
					regulator-max-microvolt = <2050000>;
					bias-pull-down;
				};

				/* LCD 2.8V */
				l8 {
					regulator-always-on; // lcm
					regulator-min-microvolt = <2800000>;
					regulator-max-microvolt = <2800000>;
					bias-pull-down;

					regulator-system-load = <100000>;
					regulator-allow-set-load;
				};

				/* CAMVANA 2.85V */
				l9 {
					regulator-always-on;
					regulator-min-microvolt = <2850000>;
					regulator-max-microvolt = <2850000>;
					bias-pull-down;
				};

				/* CWS 3V */
				l10 {
					regulator-min-microvolt = <2900000>;
					regulator-max-microvolt = <3000000>; //Konrad limited this to 2900000 on nicki
					bias-pull-down;
				};

				/* IO 1.8V */
				l11 {
					regulator-always-on;
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					bias-pull-down;

					regulator-system-load = <100000>;
					regulator-allow-set-load;
				};

				/* 1.2V */
				l12 {
					regulator-min-microvolt = <1200000>;
					regulator-max-microvolt = <1200000>;
					bias-pull-down;
				};

				/* PLL2 1.8V */
				l14 {
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					bias-pull-down;
				};

				/* USIM1 2.95V */
				l15 {
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <2950000>;
					bias-pull-down;
				};

				/* DSPMSW */
				l16 {
					regulator-min-microvolt = <375000>;
					regulator-max-microvolt = <1050000>;
					bias-pull-down;
				};

				/* USIM2 / sensors 2.95V */
				l17 {
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <2950000>;
					bias-pull-down;
				};

				/* IO / RFFE 1.8 */
				l18 {
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					bias-pull-down;
				};

				/* DSPMFW */
				l19 {
					regulator-min-microvolt = <375000>;
					regulator-max-microvolt = <1050000>;
					bias-pull-down;
				};

				/* DDRCORE 1.25V */
				l20 {
					regulator-always-on;
					regulator-min-microvolt = <1250000>;
					regulator-max-microvolt = <1250000>;
					bias-pull-down;
				};

				/* 1.9V */
				l21 {
					regulator-min-microvolt = <1900000>;
					regulator-max-microvolt = <1900000>;
					bias-pull-down;
				};

				/* SDC3 2.95V */
				l22 {
					regulator-min-microvolt = <1850000>;
					regulator-max-microvolt = <2950000>;
					bias-pull-down;
				};

				/* PLL2 1.8V */
				l23 {
					regulator-always-on;
					// ss?
					regulator-min-microvolt = <1800000>;
					regulator-max-microvolt = <1800000>;
					bias-pull-down;
				};

				/* MEM 1.15V */
				l24 {
					// ss?
					regulator-min-microvolt = <500000>;
					regulator-max-microvolt = <1150000>;
					bias-pull-down;

					regulator-system-load = <10000>; //from nicki@Konrad
					regulator-allow-set-load; //from nicki@Konrad
				};

				/* PXO 1.05V */
				l26 {
					regulator-always-on;
					regulator-min-microvolt = <1050000>;
					regulator-max-microvolt = <1050000>;
					bias-pull-down;
				};

				/* DSPAPP 1.05V */
				l27 {
					regulator-min-microvolt = <375000>;
					regulator-max-microvolt = <1050000>;
					bias-pull-down;
				};

				/* Q-Fuse 1.8V */
				lvs1 {
					bias-pull-down;
				};

				lvs2 {
					regulator-always-on;
					bias-pull-down;
				};

				usb-switch {};

				corner {
					regulator-always-on;
					// regulator-boot-on;
					regulator-min-microvolt = <3>;
					regulator-max-microvolt = <3>;
				};
			};
		};

		/*
		vsdcc_fixed: vsdcc-regulator {
			compatible = "regulator-fixed";
			regulator-name = "SDCC Power";
			regulator-min-microvolt = <2700000>;
			regulator-max-microvolt = <2700000>;
			regulator-always-on;
		};
		*/

		amba {
			/* eMMC */
			/*
			sdcc1: sdcc@12400000 {
				status = "okay";
				vmmc-supply = <&vsdcc_fixed>; //
			};
			*/
		};

#if 0
		gpu: adreno-3xx@4300000 {
			compatible =  "qcom,adreno-305.2", "qcom,adreno"; // or .0 ?
			reg = <0x04300000 0x20000>;
			reg-names = "kgsl_3d0_reg_memory";
			interrupts = <GIC_SPI 80 0>;
			interrupt-names = "kgsl_3d0_irq";
			clock-names =
			    "core_clk",
			    "iface_clk",
			    "mem_clk",
			    "mem_iface_clk";
			clocks =
			    <&mmcc GFX3D_CLK>,
			    <&mmcc GFX3D_AHB_CLK>,
			    <&mmcc GFX3D_AXI_CLK>,
			    <&mmcc MMSS_IMEM_AHB_CLK>;

#if 1
			iommus = <&gfx3d 0
				  &gfx3d 1
				  &gfx3d 2
				  &gfx3d 3
				  &gfx3d 4
				  &gfx3d 5
				  &gfx3d 6
				  &gfx3d 7
				  &gfx3d 8
				  &gfx3d 9
				  &gfx3d 10
				  &gfx3d 11
				  &gfx3d 12
				  &gfx3d 13
				  &gfx3d 14
				  &gfx3d 15
				  &gfx3d 16
				  &gfx3d 17
				  &gfx3d 18
				  &gfx3d 19
				  &gfx3d 20
				  &gfx3d 21
				  &gfx3d 22
				  &gfx3d 23
				  &gfx3d 24
				  &gfx3d 25
				  &gfx3d 26
				  &gfx3d 27
				  &gfx3d 28
				  &gfx3d 29
				  &gfx3d 30
				  &gfx3d 31>;
#endif

			qcom,gpu-pwrlevels {
				compatible = "qcom,gpu-pwrlevels";
				qcom,gpu-pwrlevel@0 {
					qcom,gpu-freq = <400000000>;
				};
				qcom,gpu-pwrlevel@1 {
					qcom,gpu-freq = <27000000>;
				};
			};
		};

		mmss_sfpb: syscon@5700000 {
			compatible = "syscon";
			reg = <0x5700000 0x70>;
		};

		dsi0: mdss_dsi@4700000 {
			compatible = "qcom,mdss-dsi-ctrl";
			label = "MDSS DSI CTRL->0";
			#address-cells = <1>;
			#size-cells = <0>;
			interrupts = <GIC_SPI 82 0>;
			reg = <0x04700000 0x200>;
			reg-names = "dsi_ctrl";

			clocks = <&mmcc DSI_M_AHB_CLK>,
				<&mmcc DSI_S_AHB_CLK>,
				<&mmcc AMP_AHB_CLK>,
				<&mmcc DSI_CLK>,
				<&mmcc DSI1_BYTE_CLK>,
				<&mmcc DSI_PIXEL_CLK>,
				<&mmcc DSI1_ESC_CLK>; /*
				<&rpmcc RPM_SYS_FABRIC_A_CLK>,
				<&rpmcc RPM_MMFPB_A_CLK>,
				<&rpmcc RPM_EBI1_A_CLK>,
				<&rpmcc RPM_DAYTONA_FABRIC_A_CLK>,
				<&rpmcc RPM_CFPB_A_CLK>,
				<&rpmcc RPM_APPS_FABRIC_A_CLK>; */
			clock-names = "iface", "bus", "core_mmss",
					"src", "byte", "pixel",
					"core"; /*,
			"sfab", "mmfpb", "ebi1", "dfab", "cfpb", "afab"; */

			/*
			sfab: 133333000
mmfpb: 38400000
ebi1: 533000000
dfab/cfpb: 64000000
afab: 533000000

			*/

			assigned-clocks = <&mmcc DSI1_BYTE_SRC>,
					<&mmcc DSI1_ESC_SRC>,
					<&mmcc DSI_SRC>,
					<&mmcc DSI_PIXEL_SRC>;
			assigned-clock-parents = <&dsi0_phy 0>,
						<&dsi0_phy 0>,
						<&dsi0_phy 1>,
						<&dsi0_phy 1>;
			// syscon-sfpb = <&mmss_sfpb>;
			phys = <&dsi0_phy>;
			ports {
				#address-cells = <1>;
				#size-cells = <0>;

				port@0 {
					reg = <0>;
					dsi0_in: endpoint {
					};
				};

				port@1 {
					reg = <1>;
					dsi0_out: endpoint {
					};
				};
			};
		};


		dsi0_phy: dsi-phy@4700200 {
			compatible = "qcom,dsi-phy-28nm-8960";
			#clock-cells = <1>;
			#phy-cells = <0>;

			reg = <0x04700200 0x100>,
				<0x04700300 0x200>,
				<0x04700500 0x5c>;
			reg-names = "dsi_pll", "dsi_phy", "dsi_phy_regulator";
			clock-names = "iface_clk";
			clocks = <&mmcc DSI_M_AHB_CLK>;
		};

		mdp: mdp@5100000 {
			compatible = "qcom,mdp4";
			reg = <0x05100000 0xf0000>;
			interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
			clocks = <&mmcc MDP_CLK>,
				 <&mmcc MDP_AHB_CLK>,
				 <&mmcc MDP_AXI_CLK>,
				 <&mmcc MDP_LUT_CLK>,
				 <&mmcc HDMI_TV_CLK>,
				 <&mmcc MDP_TV_CLK>;
			clock-names = "core_clk",
				      "iface_clk",
				      "bus_clk",
				      "lut_clk",
				      "hdmi_clk",
				      "tv_clk";
#if 1
			iommus = <&mdp_port0 0
				  &mdp_port0 2
				  &mdp_port1 0
				  &mdp_port1 2>;
#endif

			ports {
				#address-cells = <1>;
				#size-cells = <0>;

				port@0 {
					reg = <0>;
					mdp_lvds_out: endpoint {
					};
				};

				port@1 {
					reg = <1>;
					mdp_dsi1_out: endpoint {
					};
				};

				port@2 {
					reg = <2>;
					mdp_dsi2_out: endpoint {
					};
				};

				port@3 {
					reg = <3>;
					mdp_dtv_out: endpoint {
					};
				};
			};
		};

		mdp@5100000 {
			vdd-supply = <&pm8038_l23>;
			status = "okay";
			ports {
				port@1 {
					mdp_dsi1_out: endpoint {
						remote-endpoint = <&dsi0_in>;
					};
				};
			};
		};

		dsi0: mdss_dsi@4700000 {
			status = "okay";
			vdda-supply = <&pm8038_l2>; /*VDD_MIPI1 to 4*/
			avdd-supply = <&pm8038_l8>;
			vddio-supply = <&pm8038_l23>;

			panel@0 {
				reg = <0>;
				compatible = "sharp,ls043t1le01-qhd";

				reset-gpios = <&msmgpio 58 GPIO_ACTIVE_HIGH>;

				pinctrl-names = "default";
				pinctrl-0 = <&panel_pins>;

				port {
					panel_in: endpoint {
						remote-endpoint = <&dsi0_out>;
					};
				};
			};

			ports {
				port@0 {
					dsi0_in: endpoint {
						remote-endpoint = <&mdp_dsi1_out>;
					};
				};

				port@1 {
					dsi0_out: endpoint {
						remote-endpoint = <&panel_in>;
						data-lanes = <1 2>;
					};
				};
			};
		};

		dsi-phy@4700200 {
			status = "okay";
			vddio-supply = <&pm8038_l23>;/*VDD_PLL2_1 to 7*/
		};
#endif

#if 1
		mdp_port0: iommu@7500000 {
			compatible = "qcom,apq8064-iommu";
			#iommu-cells = <1>;
			clock-names =
			    "smmu_pclk",
			    "iommu_clk";
			clocks =
			    <&mmcc SMMU_AHB_CLK>,
			    <&mmcc MDP_AXI_CLK>;
			reg = <0x07500000 0x100000>;
			interrupts =
			    <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>;
			qcom,ncb = <2>;
		};

		mdp_port1: iommu@7600000 {
			compatible = "qcom,apq8064-iommu";
			#iommu-cells = <1>;
			clock-names =
			    "smmu_pclk",
			    "iommu_clk";
			clocks =
			    <&mmcc SMMU_AHB_CLK>,
			    <&mmcc MDP_AXI_CLK>;
			reg = <0x07600000 0x100000>;
			interrupts =
			    <GIC_SPI 61 0>,
			    <GIC_SPI 62 0>;
			qcom,ncb = <2>;
		};

		gfx3d: iommu@7c00000 {
			compatible = "qcom,apq8064-iommu";
			#iommu-cells = <1>;
			clock-names =
			    "smmu_pclk",
			    "iommu_clk";
			clocks =
			    <&mmcc SMMU_AHB_CLK>,
			    <&mmcc GFX3D_AXI_CLK>;
			reg = <0x07c00000 0x100000>;
			interrupts =
			    <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>;
			qcom,ncb = <3>;
		};
#endif

		usb@12500000 {
			status = "okay";
			dr_mode = "otg";
			ulpi {
				phy {
					v3p3-supply = <&pm8038_l3>;
					v1p8-supply = <&pm8038_l4>;
				};
			};
		};

#if 1
		riva-pil@3204000 {
			status = "okay";

			pinctrl-names = "default";
			pinctrl-0 = <&riva_wlan_pin_a>, <&riva_bt_pin_a>, <&riva_fm_pin_a>;
		};
#endif

#if 0
		camss: camss@4500000 {
			compatible = "qcom,msm8064-camss";
			reg =
				<0x04800000 0x400>,
				<0x04800400 0x400>,
				// <0x04801800 0x400>,

				<0x04800c00 0x400>,
				<0x04801000 0x400>,
				// <0x04801400 0x400>,

				<0x04800800 0x400>,
				<0x04500000 0x100000>;
				// vpe <0x05300000 0x100000>
			reg-names =
				"csiphy0",
				"csiphy1",
				// "csiphy2",
				"csid0",
				"csid1",
				// "csid2",
				"ispif",
				"vfe";
				// "vpe";
			interrupts =
				<GIC_SPI 139 0>,
				<GIC_SPI 140 0>,
				// <GIC_SPI 228 0>,
				<GIC_SPI 84 0>,
				<GIC_SPI 83 0>,
				// <GIC_SPI 227 0>,
				<GIC_SPI 167 0>,
				<GIC_SPI 48 0>;
				// <GIC_SPI 47 0>;
			interrupt-names =
				"csiphy0",
				"csiphy1",
				// "csiphy2",
				"csid0",
				"csid1",
				// "csid2",
				"ispif",
				"vfe";
				// "vpe";
			// power-domains = <&mmcc CAMSS_VFE_GDSC>;
			clocks =
				/* csid */
				<&mmcc CSI_AHB_CLK>,
				<&mmcc CSI0_CLK>, <&mmcc CSI0_PHY_CLK>,
				<&mmcc CSI1_CLK>, <&mmcc CSI1_PHY_CLK>,
				// <&mmcc CSI2_CLK>, <&mmcc CSI2_PHY_CLK>,

				/* csiphy */
				<&mmcc CSIPHY0_TIMER_CLK>,
				<&mmcc CSIPHY1_TIMER_CLK>,
				// <&mmcc CSIPHY2_TIMER_CLK>,

				/* ispif */
				<&mmcc CSI_PIX_CLK>, <&mmcc CSI_RDI_CLK>,
				<&mmcc CSI_PIX1_CLK>,
				<&mmcc CSI_RDI1_CLK>, <&mmcc CSI_RDI2_CLK>,

				/* vfe */
				<&mmcc VFE_CLK>,
				<&mmcc VFE_CSI_CLK>,
				<&mmcc VFE_AHB_CLK>,
				<&mmcc VFE_AXI_CLK>;

			clock-names = "csi_ahb",
				"csi0", "csi0_phy",
				"csi1", "csi1_phy",
				"csi2", "csi2_phy",
				"csiphy0_timer", "csiphy1_timer", "csiphy2_timer",

				"csi_pix", "csi_rdi", "csi_pix1", "csi1_rdi1", "csi_rdi2",

				"vfe", "csi_vfe", "vfe_ahb", "vfe_axi";

			vdda-supply = <&pm8038_l2>;
			// iommus = <...>;
			ports {
				#address-cells = <1>;
				#size-cells = <0>;
				/* port@0 {
					reg = <0>;
					csiphy0_ep: endpoint {
						clock-lanes = <1>;
						data-lanes = <0 2 3 4>;
						remote-endpoint = <&imx179_ep>;
					};
				}; */
			};
		};
#endif
    };

        //gsbi@16400000 {}; //for some reason I have turned this on in the old port
};

&msmgpio {
	sdcc1_pins: sdcc1-pin-active {
		clk {
			pins = "sdc1_clk";
			drive-strengh = <16>;
			bias-disable;
		};

		cmd {
			pins = "sdc1_cmd";
			drive-strengh = <10>;
			bias-pull-up;
		};

		data {
			pins = "sdc1_data";
			drive-strengh = <10>;
			bias-pull-up;
		};
	};

	/*
	ps_hold: ps_hold {
		mux {
			pins = "gpio108";
			function = "ps_hold";
        };
    };
	*/
    
	/*
    pmic_int: pmic_int {
		irq {
			pins = "gpio104";
			function = "gpio";

			drive-strength = <2>;
			bias-pull-down;
			
		};
	};
	*/

	riva_fm_pin_a: riva-fm-active {
		pins = "gpio26", "gpio27";
		function = "fm";
	};

	riva_bt_pin_a: riva-bt-active {
		pins = "gpio28", "gpio29", "gpio83"; // 1 extra ?
		function = "bt";
	};

	riva_wlan_pin_a: riva-wlan-active {
		pins = "gpio84", "gpio85", "gpio86", "gpio87", "gpio88";
		function = "wlan";

		drive-strength = <6>;
		bias-pull-down;
	};
};
